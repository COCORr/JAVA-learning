# 1. 接口

接口就是多个类的公共规范。
接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。

## 1.1 接口格式

如何定义一个接口的格式：

~~~java
public interface 接口名称 {
    // 接口内容
}
~~~

备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --> .class。

## 1.2 接口内容

如果是Java 7，那么接口中可以包含的内容有：

1. 常量
2. 抽象方 法

如果是Java 8，还可以额外包含有：
3. 默认方法
4. 静态方法

如果是Java 9，还可以额外包含有：
5. 私有方法

## 1.3 接口使用步骤

1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。
  格式：

  ~~~java
  public class 实现类名称 implements 接口名称 {
    // ...
  }
  ~~~

  

2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
  实现：去掉abstract关键字，加上方法体大括号。

3. 创建实现类的对象，进行使用。

## 1.4 注意事项
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。

接口是没有静态代码块或者构造方法的

一个类的直接父类是唯一的，但是一个接口可以有多个接口

## 1.5 接口的默认方法

从Java 8开始，接口里允许定义默认方法。
格式：

~~~java
public default 返回值类型 方法名称(参数列表) {
    方法体
}
~~~

备注：接口当中的默认方法，可以解决接口升级的问题。

接口的默认方法 会被继承下去
在接口升级时，如果使用抽象方法，后面的实现类都会报错
而使用默认方法时，该默认方法会被继承到实现类中

1. 接口的默认方法，可以通过接口实现类对象，直接调用。
2. 接口的默认方法，也可以被接口实现类进行覆盖重写。

## 1.6 接口的静态方法

从Java 8开始，接口当中允许定义静态方法。
格式：

~~~java
public static 返回值类型 方法名称(参数列表) {
    方法体
}
~~~

提示：就是将abstract或者default换成static即可，带上方法体。

注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。
正确用法：通过接口名称，直接调用其中的静态方法。
格式：
接口名称.静态方法名(参数);

## 1.7 接口的私有方法

问题描述：
我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。
但是这个共有方法不应该让实现类使用，应该是私有化的。
从Java 9开始，接口当中允许定义私有方法。

1. 普通私有方法，解决多个默认方法之间重复代码问题
  格式：

  ~~~java
  private 返回值类型 方法名称(参数列表) {
    方法体
  }
  ~~~

2. 静态私有方法，解决多个静态方法之间重复代码问题
  格式：

  ~~~java
  private static 返回值类型 方法名称(参数列表) {
    方法体
  }
  ~~~

由于静态方法只能访问静态成员变量、成员方法 因此该方法也需要为静态成员方法

## 1.8 接口的成员变量

接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
从效果上看，这其实就是接口的【常量】。
格式：

~~~java
public static final 数据类型 常量名称 = 数据值;
~~~

备注：
一旦使用final关键字进行修饰，说明不可改变。

注意事项：
1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。
2. 接口当中的常量，必须进行赋值；不能不赋值。
3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）

## 1.9 接口抽象方法重名

只需重写一次抽象方法即可

## 1.10 接口默认方法重名

实现类一定要对冲突的默认方法重写

## 1.11 接口方法与父类方法重名

优先使用父类的方法

## 1.12 接口的继承性

1. 类与类之间是单继承的。直接父类只有一个。
2. 类与接口之间是多实现的。一个类可以实现多个接口。
3. 接口与接口之间是多继承的。

注意事项：
1. 多个父接口当中的抽象方法如果重复，没关系。
2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。



# 2. 多态

extends继承或者implements实现，是多态性的前提

代码当中体现多态性，其实就是一句话：父类引用指向子类对象。

格式：
父类名称 对象名 = new 子类名称();
此时成员变量看父类，成员方法看子类或向上找（成员方法在继承中会覆盖，但是成员变量不会）
成员方法口诀：编译看左，运行看右
成员变量口诀：编译看左，运行也看左

或者：
接口名称 对象名 = new 实现类名称();

## 2.1 多态的应用

见图



# 3. 上下转型

向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：
对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。

# 4. instanceof

如何才能知道一个父类引用的对象，本来是什么子类？
格式：
对象 instanceof 类名称

~~~java
int i=10;
if(i instanceof int){
	//...
}
~~~

这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。